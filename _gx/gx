#!/bin/bash
shopt -s nullglob
set -e

MANIFESTS="3d anime atlas banner bg campaign card cardsm chara comic dailybonus gachaselect item jacket live loginbonus master musicscores room skill story tutorial"

# define this as an environment variable.
# default is fairly outdated, use versioncheck.py to get the current version from the server.
if [[ -z "$VERSION" ]]; then
    VERSION=10011200
fi

DBMANIFEST="http://storage.game.starlight-stage.jp/dl/$VERSION/manifests"
ASSETBBASEURL="http://storage.game.starlight-stage.jp/dl/resources/High/AssetBundles/Android"
SOUNDBASEURL="http://storage.game.starlight-stage.jp/dl/resources/High/Sound/Common"
SQLBASEURL="http://storage.game.starlight-stage.jp/dl/resources/Generic"

SCRIPT_PATH=`dirname "$0"`; SCRIPT_PATH=`eval "cd \"$SCRIPT_PATH\" && pwd"`
LZ4ER="$SCRIPT_PATH/bin/lz4er"
CURLFLAGS="-# -f"

# We can reuse these.
TMP_COMPRESSED=$(mktemp -t 'help')
TMP_SQLITE3=$(mktemp -t 'ayylmao')
touch "$TMP_COMPRESSED"
touch "$TMP_SQLITE3"
cleanup() {
    rm "$TMP_SQLITE3" "$TMP_COMPRESSED"
}
trap cleanup EXIT

get_manifest() {
    MANIFEST=$1; shift

    if [ ! -s "$TMP_SQLITE3" ]; then
        >&2 printf "===> Figuring out where the main manifest is... "
        local FILENAME=$(curl --silent $DBMANIFEST/all_dbmanifest | egrep 'Android,High,High$' | cut -f 1 -d,)
        >&2 echo $FILENAME.

        >&2 echo "===> Downloading the main manifest."
        curl $CURLFLAGS "$DBMANIFEST/$FILENAME" -o "$TMP_COMPRESSED"
        $LZ4ER "$TMP_COMPRESSED" > "$TMP_SQLITE3"
    else
        >&2 echo "===> Using cached manifest from earlier."
    fi

    if [ "$MANIFEST" == "@" ]; then
        sqlite3 "$TMP_SQLITE3" --separator " " "SELECT name, hash FROM manifests"
    else
        sqlite3 "$TMP_SQLITE3" --separator " " "SELECT name, hash FROM manifests WHERE name LIKE '${MANIFEST}\\_%' ESCAPE '\\'"
    fi
    # sqlite3 "$TMP_SQLITE3"
}

url() {
    local FILE=$1; shift
    local URL=$1; shift
    case $FILE in
    *.unity3d)
        echo "$ASSETBBASEURL/$URL" ;;
    *.mdb)
        echo "$SQLBASEURL/$URL" ;;
    *.acb)
        echo "$SOUNDBASEURL/$(dirname $FILE)/$URL" ;;
    esac
}

destfile() {
    local FILE=$1; shift
    case $FILE in
    *.unity3d)
        echo "$FILE.lz4" ;;
    *.bdb)
        echo "$FILE.lz4" ;;
    *.mdb)
        echo "$FILE.lz4" ;;
    *)
        echo "$FILE" ;;
    esac
}

download_new_file() {
    local FILE=$1; shift
    local DESTINATION=$1; shift
    local RIP_DIR=$1; shift

    >&2 echo "---> Downloading new version of file $FILE."

    if [[ "$DRY_RUN" -ne 0 ]]; then
        return
    fi

    curl $CURLFLAGS -o $DESTINATION $FILE || exit 0
    mkdir -p "$(dirname $DESTINATION)/.shadow"
    > "$(dirname $DESTINATION)/.shadow/$(basename $DESTINATION)" openssl md5 < $DESTINATION

    >&2 $SCRIPT_PATH/bin/ripper.sh $RIP_DIR _static $DESTINATION

    echo $DESTINATION
}

check_file() {
    local FILE=$1; shift
    local EXPECT_MD5=$1; shift

    [[ -f $FILE ]] || return 2

    if [[ $(cat < $(dirname $FILE)/.shadow/$(basename $FILE)) == "$EXPECT_MD5" ]]; then
        return 0
    else
        return 1
    fi
}

check_file_wrapper() {
    local STORE=$1; shift
    local DECODED=$1; shift
    local FILENAME=$1; shift
    local MD5=$1; shift

    local URL=$(url $FILENAME $MD5)
    local SCRUBBED_FILENAME=$(echo $(basename $FILENAME) | sed 's|/|_|g')
    check_file $STORE/$(destfile $SCRUBBED_FILENAME) $EXPECT_MD5 || download_new_file $URL $STORE/$(destfile $SCRUBBED_FILENAME) $DECODED
}

### tab management

source_job() {
    local TAB=$1; shift
    local WANT=""
    local FILTERS=""

    want() {
        WANT="$WANT $@"
    }

    filter_with() {
        FILTERS="$FILTERS $@"
    }

    any() {
        return 0
    }

    flush() {
        mkdir -p _store

        process_one() {
            local STORE=$1; shift
            local DECODED=$1; shift

            echo "enter process_one"
            while read FILE EXPECT_MD5; do
                if [[ "x$FILE" != "x" ]]; then

                    for FILTER_NAME in $FILTERS; do
                        $FILTER_NAME $FILE && ( check_file_wrapper $STORE $DECODED $FILE $EXPECT_MD5 )
                    done
                fi
            done
        }

        for MANIFEST in $WANT; do
            mkdir -p _store/$MANIFEST/.shadow
            get_manifest $MANIFEST | process_one "_store/$MANIFEST" "_decoded/$MANIFEST"
        done

        unset -f process_one
        FILTERS=""
        WANT=""
    }

    source $TAB

    unset -f want filter_with any flush
}

export DRY_RUN=0
if [[ "$1" = "dry-run" ]]; then
    export DRY_RUN=1
    shift
fi

>&2 echo ":: GX 2. at $(hostname) $(date) (dry run: $DRY_RUN)"

if [[ "$#" == "0" ]]; then
    for TAB in *.job; do
        >&2 echo "Executing $TAB."
        source_job $TAB
    done
else
    while (( $# )); do
        TAB=$1; shift
        >&2 echo "Executing $TAB."
        source_job $TAB
    done
fi
